<!DOCTYPE html>
<html><head><link href="http://gmpg.org/xfn/11" rel="profile"><meta content="IE=edge" http-equiv="X-UA-Compatible"><meta content="text/html; charset=utf-8" http-equiv="content-type"><meta content="width=device-width initial-scale=1.0 maximum-scale=1" name="viewport"><title>Robert Stuttaford, Clojure Enthusiast</title><link href="/css/poole.css" rel="stylesheet" type="text/css"><link href="/css/syntax.css" rel="stylesheet" type="text/css"><link href="/css/stuttaford.css" rel="stylesheet" type="text/css"><link href="/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="152x152"><link href="/favicon.ico" rel="shortcut icon"><link href="/atom.xml" rel="alternate" title="RSS" type="application/rss+xml"></head><body><div class="container content"><div class="masthead"><h3 class="masthead-title"><a href="/" title="Home">Robert Stuttaford</a> <small>Clojure Enthusiast</small></h3><small><a href="/about/">About</a></small> &middot; <small><a href="/codex/">Clojure Codex</a></small> &middot; <small>I'm on <a href="https://twitter.com/RobStuttaford">Twitter</a> and <a href="https://github.com/robert-stuttaford">GitHub</a>.</small></div><div class="posts"><div class="post"><h1 class="post-title"><a href="/2014/08/10/om-interop-with-3rd-party-libs/">Om interop with 3rd party JS libs</a></h1><span class="post-date">10 Aug 2014</span><p>A couple days ago, I cheekily tweeted a piece of code for embedding the fantastic <a href="http://ace.c9.io/">Ace</a> Javascript editor in an Om app. I say cheekily, because I wrote the code in the <a href="https://www.refheap.com">RefHeap</a> editor and didn't actually test it!</p><p></p><blockquote align="center" lang="en" class="twitter-tweet"> <p>The essence of how to use icky mutable JS components like Ace editor with <a href="https://twitter.com/hashtag/Om?src=hash">#Om</a> - well, with any <a href="https://twitter.com/hashtag/ReactJS?src=hash">#ReactJS</a> really:<a href="https://t.co/Tjx69JFsIk">https://t.co/Tjx69JFsIk</a></p>— Robert Stuttaford (@RobStuttaford) <a href="https://twitter.com/RobStuttaford/statuses/497397737923833856">August 7, 2014</a></blockquote> <script charset="utf-8" src="//platform.twitter.com/widgets.js" async="async"></script><p>Anyone who was brave enough to test it out using this code as a starting point would have run into several issues. This post attempts to make up for those, by sharing how it works and providing usable code!</p><p><strong>tl;dr</strong>: Here's the full source:</p><p><a href="https://github.com/robert-stuttaford/om-ace-demo/blob/master/src/om_ace_demo.cljs#L1">https://github.com/robert-stuttaford/om-ace-demo</a></p><h2>The basic idea</h2><p>So, as you likely already know, <a href="http://facebook.github.io/react/">React</a> (for which <a href="https://github.com/swannodette/om">Om</a> is a ClojureScript wrapper) does things a little differently; it manages two virtual DOMs - one representing the live DOM and one representing the new version of the view you want rendered. It diffs between those two to determine the minimum set of changes to make to the live DOM whenever your app has to re-render.</p><p>What this means for interop with non-React code is that we have to opt React out of managing the live DOM for this code, but only once React has created it for us. Once it's created, we represent to React that nothing about the view changes from state change to state change.</p><p>This causes the diff to yield no changes for this particular part of the virtual DOM, which of course means no mutations will occur to the live DOM nodes.</p><h2>Getting Ace on the page</h2><p>We're going to go through a working example with Ace. We'll look at:</p><ol><li>How to instantiate an Ace instance</li><li>How to populate the text editor from the Om global app state</li><li>How to track the changes occuring in Ace as they happen</li><li>And how to persist those changes back to the global Om state</li></ol><p>We'll use several life cycle protocol functions to interop with Ace. Here's a <a href="https://github.com/swannodette/om/wiki/Documentation#life-cycle-protocols">full reference of all the protocols in Om</a>.</p><p>This code comes with a couple bonuses:</p><ul><li>We'll see how to use  <a href="https://clojure.github.io/core.async/">core.async</a> to have two Om  components coordinate.</li><li>We'll use the simple but seriously handy <code>defcomponent</code> from  <a href="https://github.com/Prismatic/om-tools">om-tools</a>, which <accronym title="Don't repeat yourself">DRY</accronym>s up all the <code>reify IProtocol</code>   code you see in vanilla Om applications.</li><li>Also, we'll use <a href="https://github.com/r0man/sablono">Ŝablono</a> to  render HTML rather than the <code>om.dom</code> namespace provided by Om. I  personally find it a lot easier to read and write.</li></ul><p>Let's jump in!</p><h3>1. Instantiate an Ace instance</h3><div class="highlight"><pre>
<span class="p">(</span><span class="k">def </span><span class="nv">*ace*</span> <span class="p">(</span><span class="nf">atom</span> <span class="nv">nil</span><span class="p">))</span>                              <span class="c1">;; 1</span>

<span class="p">(</span><span class="nf">defcomponent</span> <span class="nv">editor-area</span> <span class="p">[</span><span class="nv">data</span> <span class="nv">owner</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">render</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">html</span> <span class="p">[</span><span class="ss">:div#ace</span> <span class="p">{</span><span class="ss">:style</span> <span class="p">{</span><span class="ss">:height</span> <span class="s">"400px"</span><span class="p">}}]))</span>   <span class="c1">;; 2</span>
  <span class="p">(</span><span class="nf">did-mount</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span>                                    <span class="c1">;; 3</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ace-instance</span> <span class="p">(</span><span class="nf">.edit</span> <span class="nv">js/ace</span>                <span class="c1">;; 4</span>
                              <span class="p">(</span><span class="nf">.getDOMNode</span> <span class="nv">owner</span><span class="p">))]</span> <span class="c1">;; 5</span>
      <span class="p">(</span><span class="nf">reset!</span> <span class="nv">*ace*</span> <span class="nv">ace-instance</span><span class="p">))))</span>                <span class="c1">;; 6</span>
</pre></div><ol><li>First, we set up an <code>atom</code> to store the reference to Ace so that we   can work with it later on. <strong>Fair warning</strong>: this does mean you can   only use one instance of this component at a time - yay global   mutable state!</li><li>We render a single <code>div</code> using Ŝablono's <code>html</code> macro.</li><li>We use the <code>did-mount</code> (from the <code>IDidMount</code> protocol), as this is   called once, right after the component has been made live on the DOM.</li><li>We invoke Ace's <code>edit</code> decorator function, passing it the DOM node   that we get by...</li><li>Using React's <code>getDOMNode</code> function, passing in <code>owner</code>, which is   the backing React component provided by Om.</li><li>We store the Ace reference in the atom.</li></ol><h3>2. Populate the text editor from the Om global app state</h3><p>We'll do this in two places; once on starting Ace up, and with a separate life cycle protocol function. First, a helper function:</p><div class="highlight"><pre>
<span class="p">(</span><span class="kd">defn </span><span class="nv">set-value!</span> <span class="p">[</span><span class="nv">value</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ace-instance</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">*ace*</span><span class="p">)</span>                            <span class="c1">;; 1</span>
        <span class="nv">cursor</span>       <span class="p">(</span><span class="nf">.getCursorPositionScreen</span> <span class="nv">ace-instance</span><span class="p">)]</span> <span class="c1">;; 2</span>
    <span class="p">(</span><span class="nf">.setValue</span> <span class="nv">ace-instance</span> <span class="nv">value</span> <span class="nv">cursor</span><span class="p">)))</span>                   <span class="c1">;; 3</span>
</pre></div><ol><li>We get the reference from the atom.</li><li>We grab the current text cursor position of the editor...</li><li>And pass it back in when setting the new value, so that the cursor   doesn't jump around, if at all possible - sometimes it will if the   text changes dramatically.</li></ol><p>Ok, so now we can set the editor value from the global state, using a key of <code>:value</code> for this particular state map:</p><div class="highlight"><pre>
<span class="p">(</span><span class="nf">defcomponent</span> <span class="nv">editor-area</span> <span class="p">[</span><span class="nv">data</span> <span class="nv">owner</span><span class="p">]</span>
  <span class="nv">...</span>
  <span class="p">(</span><span class="nf">did-mount</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ace-instance</span> <span class="p">(</span><span class="nf">.edit</span> <span class="nv">js/ace</span>
                              <span class="p">(</span><span class="nf">.getDOMNode</span> <span class="nv">owner</span><span class="p">))]</span>
      <span class="p">(</span><span class="nf">reset!</span> <span class="nv">*ace*</span> <span class="nv">ace-instance</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">set-value!</span> <span class="p">(</span><span class="ss">:value</span> <span class="nv">data</span><span class="p">))))</span>                  <span class="c1">;; 1</span>
  <span class="p">(</span><span class="nf">will-update</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">next-data</span> <span class="nv">next-state</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">set-value!</span> <span class="p">(</span><span class="ss">:value</span> <span class="nv">next-data</span><span class="p">))))</span>               <span class="c1">;; 2</span>
</pre></div><ol><li>Set it on start up from the initial Om cursor.</li><li>Use <code>will-update</code> (from, you guessed it, the <code>IWillUpdate</code>   protocol) to set the data from the incoming state transition cursor.</li></ol><p>Great! We have an editor on the page!</p><h2>3. Track the changes in Ace</h2><p>Now we'll use Ace's on change callback to catch changes as they happen.</p><div class="highlight"><pre>
<span class="p">(</span><span class="kd">defn </span><span class="nv">change-handler</span> <span class="p">[]</span>                             <span class="c1">;; 1</span>
  <span class="nv">???</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defcomponent</span> <span class="nv">editor-area</span> <span class="p">[</span><span class="nv">data</span> <span class="nv">owner</span><span class="p">]</span>
  <span class="nv">...</span>
  <span class="p">(</span><span class="nf">did-mount</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ace-instance</span> <span class="p">(</span><span class="nf">.edit</span> <span class="nv">js/ace</span>
                              <span class="p">(</span><span class="nf">.getDOMNode</span> <span class="nv">owner</span><span class="p">))]</span>
      <span class="p">(</span><span class="nf">reset!</span> <span class="nv">*ace*</span> <span class="nv">ace-instance</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">.. </span><span class="nv">ace-session</span>
          <span class="nv">getSession</span>
          <span class="p">(</span><span class="nf">on</span> <span class="s">"change"</span> <span class="nv">change-handler</span><span class="p">))</span>             <span class="c1">;; 2</span>
      <span class="p">(</span><span class="nf">set-value!</span> <span class="p">(</span><span class="ss">:value</span> <span class="nv">data</span><span class="p">))))</span>
  <span class="nv">...</span><span class="p">)</span>
</pre></div><ol><li>Create a change handler function.</li><li>Here we're using Clojure's nifty <code>..</code> interop convenience - here's the   <a href="http://grimoire.arrdem.com/1.6.0/clojure.core/DOT__DOT/">reference on Grimoire</a>   for that.</li></ol><p>Ok, but what do we put into that change handler?</p><hr /><h4>Interlude</h4><p>At this point, we <em>could</em> simply write the changes right back into the global app state, but there's a problem with this approach.</p><p>Doing so will cause that <code>will-update</code> function to run, which will unnecessarily update Ace to the value it already has. Remember, React isn't managing this DOM node - there's no fancy diffing to save extraneous work!</p><p>Instead, we'll use <a href="https://github.com/swannodette/om/blob/master/CHANGES.md#071">Om 0.7.1</a>'s new experimental <code>set-state-nr!</code> function to keep track of the changes without triggering a re-render, and provide a Save button for the user to click when they want their changes committed.</p><p>That way, we have the editor value available immediately, but only commit it when the user wants it. Why might we want it immediately? Well, we might decide to provide a real-time preview or validation capability!</p><p>We also need another component to compose the Save button and the editor we've just built, as we can't add any more UI to this component thanks to the way we're opting out React rendering.</p><p>Because of this, we'll need to coordinate between the container and editor components when the user clicks Save, so that the editor can transfer the editor value from local to global state.</p><p>That's where the core.async comes in.</p><hr /><h2>3. Track the changes in Ace - round two</h2><p>Right. Let's get the value from Ace into local state:</p><div class="highlight"><pre>
<span class="p">(</span><span class="kd">defn </span><span class="nv">change-handler</span> <span class="p">[</span><span class="nv">owner</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">om/set-state-nr!</span> <span class="nv">owner</span> <span class="ss">:edited-value</span>             <span class="c1">;; 1</span>
                    <span class="p">(</span><span class="nf">.getValue</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">*ace*</span><span class="p">))))</span>     <span class="c1">;; 2</span>

<span class="p">(</span><span class="nf">defcomponent</span> <span class="nv">editor-area</span> <span class="p">[</span><span class="nv">data</span> <span class="nv">owner</span><span class="p">]</span>
  <span class="nv">...</span>
  <span class="p">(</span><span class="nf">did-mount</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ace-instance</span> <span class="p">(</span><span class="nf">.edit</span> <span class="nv">js/ace</span>
                              <span class="p">(</span><span class="nf">.getDOMNode</span> <span class="nv">owner</span><span class="p">))]</span>
      <span class="p">(</span><span class="nf">reset!</span> <span class="nv">*ace*</span> <span class="nv">ace-instance</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">.. </span><span class="nv">ace-instance</span>
          <span class="nv">getSession</span>
          <span class="p">(</span><span class="nf">on</span> <span class="s">"change"</span> <span class="o">#</span><span class="p">(</span><span class="nf">change-handler</span> <span class="nv">owner</span><span class="p">))</span>     <span class="c1">;; 3</span>
      <span class="p">(</span><span class="nf">set-value!</span> <span class="p">(</span><span class="ss">:value</span> <span class="nv">data</span><span class="p">))))</span>
  <span class="nv">...</span><span class="p">)</span>
</pre></div><ol><li>Our handler writes an <code>:edited-value</code> to the component's local   state via <code>owner</code>...</li><li>Using the value from the Ace instance.</li><li>We make sure to update the event listener to pass in <code>owner</code>.</li></ol><p>Now we have the whole interop round-trip working - the text value going into Ace and back out again.</p><p>Let's put that container together:</p><div class="highlight"><pre>
<span class="p">(</span><span class="nf">defcomponent</span> <span class="nv">editor</span> <span class="p">[</span><span class="nv">data</span> <span class="nv">owner</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">init-state</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">{</span><span class="ss">:editor-chan</span> <span class="p">(</span><span class="nf">chan</span><span class="p">)})</span>                     <span class="c1">;; 1</span>
  <span class="p">(</span><span class="nf">render-state</span> <span class="p">[</span><span class="nv">_</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">editor-chan</span><span class="p">]}]</span>                    <span class="c1">;; 2</span>
    <span class="p">(</span><span class="nf">html</span>
     <span class="p">[</span><span class="ss">:div</span>
      <span class="p">[</span><span class="ss">:button</span> <span class="p">{</span><span class="ss">:onClick</span> <span class="o">#</span><span class="p">(</span><span class="nf">put!</span> <span class="nv">editor-chan</span> <span class="ss">:save!</span><span class="p">)}</span> <span class="s">"Save"</span><span class="p">]</span> <span class="c1">;; 3</span>
      <span class="p">(</span><span class="nf">-</span><span class="o">&amp;</span><span class="nv">gt</span><span class="c1">;editor-area data                                    ;; 4</span>
                     <span class="p">{</span><span class="ss">:init-state</span>                            <span class="c1">;; 5</span>
                      <span class="p">{</span><span class="ss">:editor-chan</span> <span class="nv">editor-chan</span><span class="p">}})])))</span>       <span class="c1">;; 6</span>
</pre></div><p>There's quite a bit going on here:</p><ol><li>We use the <code>init-state</code> function (yep, from the <code>IInitState</code>   protocol) to create a new async channel. It's important to do this   inside the right life cycle function, as we only want it to be created   once.</li><li>We use the <code>render-state</code> function (you're right, from the   <code>IRenderState</code> protocol), which is simply the <code>IRender</code> protocol   with a convenient way to get at the local state baked in; as a function   argument. Thanks to that, we destructure the channel out.</li><li>We have our mighty Save button, which simply writes the keyword <code>:save!</code> to   the channel every time it is clicked.</li><li>We instantiate our <code>editor-area</code> component, using om-tools'   shorthand <br /><code>-&gt;component</code> syntax, which boils down to "<code>om/build component</code>".</li><li>We pass an initial state for our editor using   <a href="https://github.com/swannodette/om/wiki/Documentation#build">om/build</a>'s   third argument. This will become available as local state inside   <code>editor-area</code>.</li><li>And that state is simply a map with the channel we created at 1.</li></ol><p>Ok. Now we have the appropriate signalling in place to know when to transfer the value from local to global state.</p><p>Now, inside <code>editor-area</code>, we just need to respond to that signal:</p><div class="highlight"><pre>
<span class="p">(</span><span class="nf">defcomponent</span> <span class="nv">editor-area</span> <span class="p">[</span><span class="nv">data</span> <span class="nv">owner</span><span class="p">]</span>
  <span class="nv">...</span>
  <span class="p">(</span><span class="nf">will-mount</span> <span class="p">[</span><span class="nv">_</span><span class="p">]</span>                                          <span class="c1">;; 1</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">editor-chan</span> <span class="p">(</span><span class="nf">om/get-state</span> <span class="nv">owner</span> <span class="ss">:editor-chan</span><span class="p">)]</span>   <span class="c1">;; 2</span>
      <span class="p">(</span><span class="nf">go</span>                                                  <span class="c1">;; 3</span>
        <span class="p">(</span><span class="nf">while</span> <span class="nv">true</span>                                        <span class="c1">;; 4</span>
          <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="ss">:save!</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">lt</span><span class="c1">;! editor-chan))                ;; 5</span>
            <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">edited-value</span>
                       <span class="p">(</span><span class="nf">om/get-state</span> <span class="nv">owner</span> <span class="ss">:edited-value</span><span class="p">)]</span> <span class="c1">;; 6</span>
              <span class="p">(</span><span class="nf">om/update!</span> <span class="nv">data</span> <span class="ss">:value</span> <span class="nv">edited-value</span><span class="p">)))))))</span>  <span class="c1">;; 7</span>
  <span class="nv">...</span><span class="p">)</span>
</pre></div><ol><li>Set everything up in the <code>will-mount</code> function (from the   <code>IWillMount</code> protocol, of course). We could do this in <code>did-mount</code>,   too, but now you're aware that <code>will-mount</code> exists :-)</li><li>Grab the channel from local state.</li><li>Start a core.async <code>go</code> block, which allows us to write   synchronous-looking but-actually-asynchronous code.</li><li>Loop endlessly, so that we can catch each successive channel value.</li><li>Using <code>&lt;!</code>, block until there's a value on the channel, and if that   value is <code>:save!</code>...</li><li>Try to get the edited value from local state...</li><li>And if it's there, use <code>om/update!</code> to place it in the global state map.</li></ol><p>Phew! Now we have everything wired up.</p><h2>Conclusion</h2><p>Here's the full source, again:</p><p><a href="https://github.com/robert-stuttaford/om-ace-demo/blob/master/src/om_ace_demo.cljs#L1">https://github.com/robert-stuttaford/om-ace-demo</a></p><p>We have covered quite a lot ground in just ±50 lines of code:</p><ul><li>We got a mutable non-React Javascript library to live in harmony with an  Om/React app, which showed us Javascript interop syntax and several Om life  cycle protocols in action.</li><li>We used core.async to coordinate between two components, thus avoiding  callbacks between them.</li><li>We saw how om-tools and Ŝablono look when used with Om, which is  mostly a feel-good thing, I believe it helps a lot in the long run.</li></ul><h2>Special thanks</h2><p>To <a href="https://twitter.com/levanderhart">Luke VanderHart</a> for the conversation that led me to this insight.</p><p class="post-suffix">I hope you found this post useful. I don't have comments on here yet, but please feel free to reach out on <a href="https://twitter.com/RobStuttaford">Twitter</a>!</p></div><div class="related"><h2>Related Posts</h2><ul class="related-posts"><li><h3><a href="/2014/08/07/configuration-in-om-apps/">Configuration in Om apps <small>07 Aug 2014</small></a></h3></li><li><h3><a href="/2014/08/04/welcome/">Welcome! <small>04 Aug 2014</small></a></h3></li></ul></div></div><div class="footer"><p>&copy; Robert Stuttaford 2014. All rights reserved. Some lefts, too.</p><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-53515800-1', 'www.stuttaford.me');
    ga('send', 'pageview');</script></div></div></body></html>